1) Create a tiny custom ESLint plugin inside your repo
✅ Create folder
/eslint-rules/
  index.js
  enforce-logo-registry.js

✅ eslint-rules/enforce-logo-registry.js
/**
 * Enforce theme-aware logos via central registry.
 *
 * Rules:
 * 1) Disallow any <img src="https://..."> or <img src="http://..."> (logos must be local)
 * 2) Disallow string literals containing "/logos/" anywhere EXCEPT in:
 *    - client/src/config/logos.ts (the registry)
 *    - optional allowlist: client/public/logos/** (not in JS anyway)
 * 3) Disallow CSS invert/filter hacks in style objects and className strings:
 *    - "invert", "filter: invert", "brightness", "contrast" (common logo hacks)
 *
 * Adjust allowed paths if your structure differs.
 */

const path = require("path");

function isRegistryFile(filename) {
  const norm = filename.split(path.sep).join("/");
  return norm.endsWith("/client/src/config/logos.ts") || norm.endsWith("/client/src/config/logos.tsx");
}

function isStringLiteral(node) {
  return node && (node.type === "Literal" || node.type === "TemplateLiteral");
}

function getStringValue(node) {
  if (!node) return null;
  if (node.type === "Literal" && typeof node.value === "string") return node.value;
  if (node.type === "TemplateLiteral" && node.quasis?.length === 1) return node.quasis[0].value.cooked;
  return null;
}

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "Force logo usage via theme-aware registry (no inline logo paths, no external urls, no invert hacks).",
    },
    schema: [],
    messages: {
      noExternalImgSrc:
        "Do not use external URLs in <img src>. Logos must come from local assets via the logo registry.",
      noDirectLogoPath:
        "Do not reference '/logos/…' directly. Import from the logo registry: client/src/config/logos.ts",
      noLogoFilterHack:
        "Do not use invert/brightness/contrast filter hacks for logos. Use theme-aware SVG variants + logo container.",
    },
  },

  create(context) {
    const filename = context.getFilename();

    const isRegistry = isRegistryFile(filename);

    function checkString(node, value) {
      if (!value) return;

      // 2) Disallow direct '/logos/' usage outside registry
      if (!isRegistry && value.includes("/logos/")) {
        context.report({ node, messageId: "noDirectLogoPath" });
      }

      // 3) Disallow filter/invert hacks (common offenders)
      const lower = value.toLowerCase();
      const suspicious =
        lower.includes("invert") ||
        lower.includes("filter:") ||
        lower.includes("brightness") ||
        lower.includes("contrast");

      if (suspicious) {
        context.report({ node, messageId: "noLogoFilterHack" });
      }
    }

    return {
      // 1) Disallow external URLs in <img src="https://...">
      JSXOpeningElement(node) {
        if (node.name?.name !== "img") return;

        const srcAttr = node.attributes?.find(
          (a) => a.type === "JSXAttribute" && a.name?.name === "src"
        );
        if (!srcAttr) return;

        // <img src="...">
        if (srcAttr.value && srcAttr.value.type === "Literal") {
          const val = srcAttr.value.value;
          if (typeof val === "string" && (val.startsWith("http://") || val.startsWith("https://"))) {
            context.report({ node: srcAttr, messageId: "noExternalImgSrc" });
          }
          checkString(srcAttr.value, val);
        }

        // <img src={`...`}>
        if (srcAttr.value && srcAttr.value.type === "JSXExpressionContainer") {
          const expr = srcAttr.value.expression;
          const str = getStringValue(expr);
          if (str && (str.startsWith("http://") || str.startsWith("https://"))) {
            context.report({ node: srcAttr, messageId: "noExternalImgSrc" });
          }
          checkString(expr, str);
        }
      },

      // Catch string literals anywhere (className, style strings, etc.)
      Literal(node) {
        if (typeof node.value === "string") checkString(node, node.value);
      },

      TemplateLiteral(node) {
        const str = getStringValue(node);
        checkString(node, str);
      },
    };
  },
};

✅ eslint-rules/index.js
module.exports = {
  rules: {
    "enforce-logo-registry": require("./enforce-logo-registry"),
  },
};

2) Wire it into ESLint
If you have .eslintrc.js

Add:

const localRules = require("./eslint-rules");

module.exports = {
  // ... your existing config
  plugins: ["local"],
  rules: {
    "local/enforce-logo-registry": "error",
  },
  settings: {},
  // Register local plugin
  // eslint doesn't natively load arbitrary objects as plugins,
  // so we inject it via "plugins" using a trick below:
  // (Most setups accept this pattern)
  // If your ESLint complains, use the alternative approach in section 3.
  overrides: [
    {
      files: ["**/*.{js,jsx,ts,tsx}"],
      plugins: {
        local: localRules,
      },
    },
  ],
};


If your ESLint version doesn’t accept plugins: { local: ... }, use the “Alternative approach” below.

3) Alternative approach (most reliable): eslint-plugin-local-rules
Install:
npm i -D eslint-plugin-local-rules

Then in .eslintrc.js:
module.exports = {
  plugins: ["local-rules"],
  rules: {
    "local-rules/enforce-logo-registry": "error",
  },
  settings: {
    "local-rules/rules": {
      "enforce-logo-registry": require("./eslint-rules/enforce-logo-registry"),
    },
  },
};


This approach works very consistently across CI + Next.js.

4) Add one extra guardrail: forbid “/logos/” import paths except the registry file

If you want it even stricter, add this to ESLint rules:

"no-restricted-syntax": [
  "error",
  {
    selector: "ImportDeclaration[source.value=/\\/logos\\//]",
    message: "Do not import directly from /logos/. Use the registry in client/src/config/logos.ts",
  },
],


(Your custom rule already catches this in strings, but this also catches import usage patterns.)

5) What this will enforce immediately

✅ Blocks:

src="https://…" anywhere

"/logos/aws/aws-dark.svg" hardcoded in components

className="invert" or style={{ filter: "invert(1)" }}

✅ Forces:

Central registry usage (client/src/config/logos.ts)

Theme-aware assets, not hacks